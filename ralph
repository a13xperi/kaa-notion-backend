#!/bin/bash
#
# RALPH - Production-Grade Autonomous Loop for Claude Code
# Multi-agent orchestrator with circuit breakers, rollback, and safety mechanisms
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RALPH_LOCAL="${SCRIPT_DIR}/.ralph"
RALPH_GLOBAL="${HOME}/.ralph"
RALPH_STATE="${RALPH_GLOBAL}/state.json"
RALPH_LOG="${RALPH_GLOBAL}/ralph.log"
RALPH_METRICS="${RALPH_GLOBAL}/metrics.json"
CONFIG_FILE="${SCRIPT_DIR}/.ralph.json"
PROMPT_FILE="${SCRIPT_DIR}/PROMPT.md"
ACTIVITY_LOG="${SCRIPT_DIR}/.ralph-output.log"
CHECKPOINT_DIR="${RALPH_GLOBAL}/checkpoints"
GIT_STASH_PREFIX="ralph-checkpoint"

# Colors
R='\033[0;31m' G='\033[0;32m' Y='\033[1;33m' B='\033[0;34m'
C='\033[0;36m' M='\033[0;35m' W='\033[1;37m' N='\033[0m' DIM='\033[2m'
BOLD='\033[1m'

# Ensure directories exist
mkdir -p "${RALPH_GLOBAL}" "${RALPH_LOCAL}/prompts" "${RALPH_LOCAL}/queue" "${CHECKPOINT_DIR}"

# ══════════════════════════════════════════════════════════════════════════════
# STATE MANAGEMENT
# ══════════════════════════════════════════════════════════════════════════════

init_state() {
    if [[ ! -f "${RALPH_STATE}" ]] || [[ ! -s "${RALPH_STATE}" ]]; then
        cat > "${RALPH_STATE}" << 'EOF'
{
  "iteration": 0,
  "status": "idle",
  "started": null,
  "lastUpdate": null,
  "circuitBreaker": {
    "state": "closed",
    "noProgressCount": 0,
    "sameErrorCount": 0,
    "testOnlyCount": 0,
    "failureCount": 0,
    "tripReason": null
  },
  "session": {
    "totalIterations": 0,
    "totalCost": 0,
    "gitCheckpoint": null
  }
}
EOF
    fi
}

init_state

get_state() {
    local path="$1"
    local default="${2:-}"
    jq -r "${path} // empty" "${RALPH_STATE}" 2>/dev/null || echo "${default}"
}

set_state() {
    local updates="$1"
    local tmp="${RALPH_STATE}.tmp.$$"
    if jq ". * ${updates}" "${RALPH_STATE}" > "${tmp}" 2>/dev/null; then
        mv "${tmp}" "${RALPH_STATE}"
    else
        rm -f "${tmp}"
    fi
}

get_config() {
    local path="$1"
    local default="$2"
    if [[ -f "${CONFIG_FILE}" ]]; then
        jq -r "${path} // empty" "${CONFIG_FILE}" 2>/dev/null || echo "${default}"
    else
        echo "${default}"
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# UI COMPONENTS
# ══════════════════════════════════════════════════════════════════════════════

banner() {
    echo -e "${C}"
    cat << 'EOF'
  ╦═╗╔═╗╦  ╔═╗╦ ╦
  ╠╦╝╠═╣║  ╠═╝╠═╣
  ╩╚═╩ ╩╩═╝╩  ╩ ╩
EOF
    echo -e "${N}  ${DIM}Production-Grade Autonomous Loop${N}"
    echo ""
}

divider() { echo -e "${DIM}────────────────────────────────────────────────${N}"; }

ok()   { echo -e "  ${G}✓${N} $*"; }
warn() { echo -e "  ${Y}!${N} $*"; }
err()  { echo -e "  ${R}✗${N} $*"; }
info() { echo -e "  ${B}○${N} $*"; }

# ══════════════════════════════════════════════════════════════════════════════
# PRE-FLIGHT CHECKS
# ══════════════════════════════════════════════════════════════════════════════

preflight_check() {
    local errors=0

    echo -e "${W}PRE-FLIGHT CHECKS${N}"
    divider

    # Check PROMPT.md exists
    if [[ -f "${PROMPT_FILE}" ]]; then
        ok "PROMPT.md exists"
    else
        err "PROMPT.md missing - create with ./ralph new"
        errors=$((errors + 1))
    fi

    # Check PROMPT.md has completion promise
    if [[ -f "${PROMPT_FILE}" ]] && grep -q "RALPH_COMPLETE" "${PROMPT_FILE}"; then
        ok "Completion promise found"
    elif [[ -f "${PROMPT_FILE}" ]]; then
        warn "No RALPH_COMPLETE in prompt (will use default)"
    fi

    # Check git status
    if git rev-parse --git-dir >/dev/null 2>&1; then
        ok "Git repository detected"
        local dirty=$(git status --porcelain 2>/dev/null | wc -l)
        if [[ ${dirty} -gt 0 ]]; then
            warn "Uncommitted changes (${dirty} files) - consider committing first"
        else
            ok "Working directory clean"
        fi
    else
        warn "Not a git repository - rollback unavailable"
    fi

    # Check claude command
    if command -v claude &>/dev/null; then
        ok "Claude Code CLI found"
    else
        err "Claude Code CLI not found"
        errors=$((errors + 1))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        ok "jq installed"
    else
        err "jq required but not found"
        errors=$((errors + 1))
    fi

    # Check disk space (need at least 100MB)
    local available=$(df -m "${SCRIPT_DIR}" 2>/dev/null | tail -1 | awk '{print $4}')
    if [[ -n "${available}" ]] && [[ ${available} -gt 100 ]]; then
        ok "Disk space OK (${available}MB available)"
    else
        warn "Low disk space"
    fi

    # Check for existing loop
    local status=$(get_state '.status' 'idle')
    if [[ "${status}" == "running" ]]; then
        warn "Previous loop may still be running"
    else
        ok "No active loop"
    fi

    echo ""

    if [[ ${errors} -gt 0 ]]; then
        echo -e "${R}Pre-flight failed with ${errors} error(s)${N}"
        return 1
    fi

    echo -e "${G}All checks passed${N}"
    return 0
}

# ══════════════════════════════════════════════════════════════════════════════
# GIT ROLLBACK / UNDO STACK
# ══════════════════════════════════════════════════════════════════════════════

create_git_checkpoint() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 0
    fi

    local checkpoint_name="${GIT_STASH_PREFIX}-$(date +%Y%m%d-%H%M%S)"
    local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "")

    # Store current commit for rollback
    set_state "{\"session\": {\"gitCheckpoint\": \"${current_commit}\"}}"

    # Create a lightweight tag for easy recovery
    git tag -f "ralph-start-$(date +%Y%m%d-%H%M%S)" HEAD 2>/dev/null || true

    echo "${current_commit}"
}

rollback_to_checkpoint() {
    local checkpoint=$(get_state '.session.gitCheckpoint' '')

    if [[ -z "${checkpoint}" ]]; then
        echo -e "${R}No checkpoint found${N}"
        return 1
    fi

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${R}Not a git repository${N}"
        return 1
    fi

    echo -e "${Y}Rolling back to checkpoint: ${checkpoint:0:8}${N}"
    echo ""

    # Show what will be undone
    echo -e "${W}Changes to be reverted:${N}"
    git diff --stat "${checkpoint}" HEAD 2>/dev/null | head -20

    echo ""
    read -p "Proceed with rollback? [y/N] " confirm

    if [[ "${confirm}" =~ ^[Yy]$ ]]; then
        git reset --hard "${checkpoint}"
        echo -e "${G}Rolled back successfully${N}"
    else
        echo "Rollback cancelled"
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# COST TRACKING
# ══════════════════════════════════════════════════════════════════════════════

estimate_cost() {
    local iterations="$1"
    local cost_per_iter=$(get_config '.costs.estimatedPerIteration' '1.50')
    echo "scale=2; ${iterations} * ${cost_per_iter}" | bc 2>/dev/null || echo "?"
}

check_budget() {
    local current_cost=$(get_state '.session.totalCost' '0')
    local budget_warning=$(get_config '.costs.budgetWarningAt' '50')
    local budget_stop=$(get_config '.costs.budgetStopAt' '100')

    if (( $(echo "${current_cost} >= ${budget_stop}" | bc -l 2>/dev/null || echo 0) )); then
        echo "exceeded"
        return 1
    elif (( $(echo "${current_cost} >= ${budget_warning}" | bc -l 2>/dev/null || echo 0) )); then
        echo "warning"
        return 0
    else
        echo "ok"
        return 0
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# HEALTH CHECK
# ══════════════════════════════════════════════════════════════════════════════

health_check() {
    echo -e "${W}HEALTH CHECK${N}"
    divider

    # Circuit breaker state
    local cb_state=$(get_state '.circuitBreaker.state' 'closed')
    local cb_reason=$(get_state '.circuitBreaker.tripReason' '')

    if [[ "${cb_state}" == "closed" ]]; then
        ok "Circuit breaker: ${G}CLOSED${N}"
    else
        err "Circuit breaker: ${R}OPEN${N} (${cb_reason})"
    fi

    # Counter states
    local no_progress=$(get_state '.circuitBreaker.noProgressCount' '0')
    local same_error=$(get_state '.circuitBreaker.sameErrorCount' '0')
    local test_only=$(get_state '.circuitBreaker.testOnlyCount' '0')

    if [[ ${no_progress} -gt 0 ]]; then
        warn "No progress counter: ${no_progress}/4"
    else
        ok "Progress: Making changes"
    fi

    if [[ ${same_error} -gt 0 ]]; then
        warn "Same error counter: ${same_error}/5"
    else
        ok "Errors: No repeated errors"
    fi

    if [[ ${test_only} -gt 0 ]]; then
        warn "Test-only counter: ${test_only}/5"
    else
        ok "Activity: Making code changes"
    fi

    # Budget
    local budget_status=$(check_budget)
    case "${budget_status}" in
        exceeded) err "Budget: ${R}EXCEEDED${N}" ;;
        warning)  warn "Budget: Approaching limit" ;;
        ok)       ok "Budget: Within limits" ;;
    esac

    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
# PROMPT GENERATION
# ══════════════════════════════════════════════════════════════════════════════

generate_prompt() {
    local zone="$1"
    local task="$2"

    local template="${RALPH_LOCAL}/prompts/${zone}.md"
    [[ -f "${template}" ]] || template="${RALPH_LOCAL}/prompts/fullstack.md"

    if [[ -f "${template}" ]]; then
        sed -e "s|{{TASK}}|${task}|g" "${template}"
    else
        cat << EOF
# Task: ${task}

## Zone: ${zone}

## Success Criteria
- [ ] All requirements implemented
- [ ] Tests pass: npm test
- [ ] No TypeScript errors

## Workflow
1. Make incremental changes
2. Test after each change
3. Fix errors before proceeding

When ALL criteria met, output: RALPH_COMPLETE
EOF
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# COMMANDS
# ══════════════════════════════════════════════════════════════════════════════

cmd_new() {
    banner

    echo -e "${W}PLATFORM ZONES${N}"
    divider
    echo -e "  ${C}1${N}) frontend   - React, TypeScript, Tailwind"
    echo -e "  ${C}2${N}) backend    - Express, Prisma, Node.js"
    echo -e "  ${C}3${N}) database   - PostgreSQL, migrations"
    echo -e "  ${C}4${N}) fullstack  - End-to-end features"
    echo -e "  ${C}5${N}) tests      - Jest, Playwright"
    echo ""

    read -p "Zone [1-5]: " zone_num
    case "${zone_num}" in
        1) zone="frontend" ;;
        2) zone="backend" ;;
        3) zone="database" ;;
        4) zone="fullstack" ;;
        5) zone="tests" ;;
        *) zone="fullstack" ;;
    esac

    echo ""
    read -p "Task description: " task_desc
    echo ""
    read -p "Max iterations [30]: " max_iter
    max_iter="${max_iter:-30}"

    generate_prompt "${zone}" "${task_desc}" > "${PROMPT_FILE}"

    # Estimate cost
    local est_cost=$(estimate_cost "${max_iter}")

    echo ""
    echo -e "${G}Task created${N}"
    divider
    echo -e "  Zone:       ${C}${zone}${N}"
    echo -e "  Iterations: ${W}${max_iter}${N}"
    echo -e "  Est. cost:  ${Y}\$${est_cost}${N}"
    echo ""
    echo -e "${W}Next:${N}"
    echo "  1. Review:  ./ralph edit"
    echo "  2. Start:   ./ralph start ${max_iter}"
}

cmd_start() {
    local max="${1:-30}"
    local skip_checks="${2:-}"

    banner

    # Pre-flight checks (can skip with --force)
    if [[ "${skip_checks}" != "--force" ]]; then
        if ! preflight_check; then
            echo ""
            echo "Use './ralph start ${max} --force' to skip checks"
            exit 1
        fi
        echo ""
    fi

    # Create git checkpoint
    echo -e "${W}CREATING CHECKPOINT${N}"
    divider
    local checkpoint=$(create_git_checkpoint)
    if [[ -n "${checkpoint}" ]]; then
        ok "Git checkpoint: ${checkpoint:0:8}"
    else
        info "Git checkpoint: Skipped (not a git repo)"
    fi

    # Estimate cost
    local est_cost=$(estimate_cost "${max}")
    info "Estimated cost: \$${est_cost}"
    echo ""

    # Update config
    cat > "${CONFIG_FILE}" << EOF
{
  "maxIterations": ${max},
  "completionPromise": "RALPH_COMPLETE",
  "started": "$(date -Iseconds)",
  "circuitBreaker": {
    "noProgressThreshold": 4,
    "sameErrorThreshold": 5,
    "testOnlyThreshold": 5,
    "consecutiveFailures": 3
  },
  "costs": {
    "estimatedPerIteration": 1.50,
    "budgetWarningAt": 50,
    "budgetStopAt": 100
  }
}
EOF

    # Reset state
    set_state '{
        "iteration": 0,
        "status": "running",
        "started": "'"$(date -Iseconds)"'",
        "circuitBreaker": {
            "state": "closed",
            "noProgressCount": 0,
            "sameErrorCount": 0,
            "testOnlyCount": 0,
            "failureCount": 0,
            "tripReason": null
        }
    }'

    rm -f "${SCRIPT_DIR}/.ralph-stop" "${ACTIVITY_LOG}"
    touch "${ACTIVITY_LOG}"

    # Show task preview
    echo -e "${W}TASK${N}"
    divider
    head -10 "${PROMPT_FILE}" | sed 's/^/  /'
    echo -e "  ${DIM}...${N}"
    echo ""

    echo -e "${G}LAUNCHING${N}"
    divider
    echo -e "  Iterations: ${W}${max}${N}"
    echo -e "  Monitor:    ${C}./ralph watch${N}"
    echo -e "  Stop:       ${C}./ralph stop${N}"
    echo -e "  Rollback:   ${C}./ralph rollback${N}"
    echo ""

    local prompt=$(cat "${PROMPT_FILE}")

    cd "${SCRIPT_DIR}"
    exec claude --dangerously-skip-permissions "${prompt}

════════════════════════════════════════════════════════════════════════════════
RALPH AUTONOMOUS LOOP
════════════════════════════════════════════════════════════════════════════════

Work continuously on this task. Your progress is automatically saved.

IMPORTANT:
• Make incremental, testable changes
• Run tests after each change: npm test
• Fix errors before proceeding
• When ALL success criteria are met, output exactly: RALPH_COMPLETE

The loop will continue until you output RALPH_COMPLETE or reach max iterations.
════════════════════════════════════════════════════════════════════════════════"
}

cmd_status() {
    banner

    local iter=$(get_state '.iteration' '0')
    local status=$(get_state '.status' 'idle')
    local max=$(get_config '.maxIterations' '30')
    local started=$(get_state '.started' '-')

    echo -e "${W}STATUS${N}"
    divider

    # Status indicator
    case "${status}" in
        running)        echo -e "  State:      ${G}● RUNNING${N}" ;;
        complete)       echo -e "  State:      ${G}✓ COMPLETE${N}" ;;
        stopped)        echo -e "  State:      ${Y}■ STOPPED${N}" ;;
        max_iterations) echo -e "  State:      ${Y}! MAX ITERATIONS${N}" ;;
        circuit_breaker) echo -e "  State:      ${R}⚡ CIRCUIT BREAKER${N}" ;;
        *)              echo -e "  State:      ${DIM}○ IDLE${N}" ;;
    esac

    echo -e "  Iteration:  ${W}${iter}${N} / ${max}"
    echo -e "  Started:    ${DIM}${started}${N}"
    echo ""

    # Circuit breaker details
    local cb_state=$(get_state '.circuitBreaker.state' 'closed')
    echo -e "${W}CIRCUIT BREAKER${N}"
    divider

    if [[ "${cb_state}" == "closed" ]]; then
        echo -e "  State: ${G}CLOSED${N} (healthy)"
    else
        local reason=$(get_state '.circuitBreaker.tripReason' 'unknown')
        echo -e "  State: ${R}OPEN${N} (${reason})"
    fi

    local no_progress=$(get_state '.circuitBreaker.noProgressCount' '0')
    local same_error=$(get_state '.circuitBreaker.sameErrorCount' '0')
    local test_only=$(get_state '.circuitBreaker.testOnlyCount' '0')

    echo -e "  No Progress:  ${no_progress}/4"
    echo -e "  Same Error:   ${same_error}/5"
    echo -e "  Test Only:    ${test_only}/5"
    echo ""

    # Checkpoint
    local checkpoint=$(get_state '.session.gitCheckpoint' '')
    if [[ -n "${checkpoint}" ]]; then
        echo -e "${W}RECOVERY${N}"
        divider
        echo -e "  Checkpoint: ${checkpoint:0:8}"
        echo -e "  Rollback:   ${C}./ralph rollback${N}"
        echo ""
    fi

    # Recent activity
    if [[ -f "${ACTIVITY_LOG}" ]] && [[ -s "${ACTIVITY_LOG}" ]]; then
        echo -e "${W}RECENT ACTIVITY${N}"
        divider
        tail -5 "${ACTIVITY_LOG}" | sed 's/^/  /'
        echo ""
    fi
}

cmd_watch() {
    banner
    echo -e "${W}WATCHING${N} ${DIM}(Ctrl+C to exit)${N}"
    divider
    echo ""

    if [[ -f "${ACTIVITY_LOG}" ]]; then
        tail -f "${ACTIVITY_LOG}" 2>/dev/null
    else
        echo "Waiting for activity..."
        while [[ ! -f "${ACTIVITY_LOG}" ]]; do sleep 1; done
        tail -f "${ACTIVITY_LOG}"
    fi
}

cmd_stop() {
    touch "${SCRIPT_DIR}/.ralph-stop"
    set_state '{"status": "stopped"}'
    echo -e "${Y}Stop signal sent${N}"
    echo "Loop will exit on next iteration."
}

cmd_reset() {
    cat > "${RALPH_STATE}" << 'EOF'
{
  "iteration": 0,
  "status": "idle",
  "started": null,
  "circuitBreaker": {"state": "closed", "noProgressCount": 0, "sameErrorCount": 0, "testOnlyCount": 0},
  "session": {"totalIterations": 0, "totalCost": 0, "gitCheckpoint": null}
}
EOF
    rm -f "${SCRIPT_DIR}/.ralph-stop" "${ACTIVITY_LOG}"
    echo -e "${G}Ralph reset${N}"
}

cmd_rollback() {
    banner
    echo -e "${W}ROLLBACK${N}"
    divider
    rollback_to_checkpoint
}

cmd_health() {
    banner
    health_check
}

cmd_zone() {
    local zone="${1:-fullstack}"
    local task="${2:-Implement improvements}"
    generate_prompt "${zone}" "${task}" > "${PROMPT_FILE}"
    echo -e "${G}Zone prompt created: ${zone}${N}"
}

cmd_edit() {
    if command -v cursor &>/dev/null; then
        cursor "${PROMPT_FILE}"
    elif command -v code &>/dev/null; then
        code "${PROMPT_FILE}"
    elif [[ -n "${EDITOR:-}" ]]; then
        "${EDITOR}" "${PROMPT_FILE}"
    else
        nano "${PROMPT_FILE}" 2>/dev/null || vi "${PROMPT_FILE}"
    fi
}

cmd_logs() {
    local n="${1:-50}"
    if [[ -f "${RALPH_LOG}" ]]; then
        echo -e "${W}LOGS${N} ${DIM}(last ${n})${N}"
        divider
        tail -"${n}" "${RALPH_LOG}"
    else
        echo "No logs yet"
    fi
}

cmd_dashboard() {
    watch -n 2 -c "./ralph status"
}

cmd_preflight() {
    banner
    preflight_check
}

cmd_help() {
    banner

    echo -e "${W}COMMANDS${N}"
    divider
    echo ""
    echo -e "  ${C}Task Creation${N}"
    echo -e "    new              Interactive task wizard"
    echo -e "    zone <zone>      Quick zone (frontend|backend|database|fullstack|tests)"
    echo -e "    edit             Edit PROMPT.md"
    echo ""
    echo -e "  ${C}Execution${N}"
    echo -e "    start [N]        Start loop (default: 30 iterations)"
    echo -e "    stop             Stop gracefully"
    echo -e "    preflight        Run pre-flight checks only"
    echo ""
    echo -e "  ${C}Monitoring${N}"
    echo -e "    status           State + circuit breaker"
    echo -e "    health           Health check"
    echo -e "    watch            Live activity"
    echo -e "    logs [N]         Log history"
    echo -e "    dashboard        Auto-refresh status"
    echo ""
    echo -e "  ${C}Recovery${N}"
    echo -e "    rollback         Revert to checkpoint"
    echo -e "    reset            Clear all state"
    echo ""
    echo -e "${W}QUICK START${N}"
    divider
    echo ""
    echo "  ./ralph new          # Create task"
    echo "  ./ralph start 30     # Run loop"
    echo "  ./ralph watch        # Monitor"
    echo ""
    echo -e "${W}SAFETY FEATURES${N}"
    divider
    echo ""
    echo "  • Circuit breaker (stuck detection)"
    echo "  • Git checkpoint (rollback)"
    echo "  • Pre-flight checks"
    echo "  • Cost estimation"
    echo ""
}

# ══════════════════════════════════════════════════════════════════════════════
# MAIN
# ══════════════════════════════════════════════════════════════════════════════

case "${1:-help}" in
    new)        cmd_new ;;
    start)      cmd_start "${2:-30}" "${3:-}" ;;
    stop)       cmd_stop ;;
    status)     cmd_status ;;
    health)     cmd_health ;;
    watch)      cmd_watch ;;
    logs)       cmd_logs "${2:-50}" ;;
    dashboard)  cmd_dashboard ;;
    preflight)  cmd_preflight ;;
    rollback)   cmd_rollback ;;
    reset)      cmd_reset ;;
    zone)       cmd_zone "${2:-fullstack}" "${3:-}" ;;
    edit)       cmd_edit ;;
    help|-h|--help) cmd_help ;;
    *)
        echo -e "${R}Unknown: $1${N}"
        echo "Run './ralph help'"
        exit 1
        ;;
esac
